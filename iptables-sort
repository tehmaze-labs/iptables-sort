#!/usr/bin/env python

import datetime
import fnmatch
import subprocess
import sys


IPTABLES_SAVE = '/sbin/iptables-save'
IPTABLES_RESTORE = '/sbin/iptables-restore'
IPTABLES_OPTIONS = dict(
    A='chain',
    j='target',
    m='match',
)


class IPTablesFragment(object):
    def __init__(self, line):
        self.parse(line)

    def __str__(self):
        raise NotImplementedError

    def __repr__(self):
        name = self.__class__.__name__.replace('IPTables', '')
        bits = [name]

        for attr in self.__dict__:
            if attr.startswith('_'):
                continue

            item = getattr(self, attr)
            if isinstance(attr, basestring) or \
                    type(attr) in (int, long, float):
                bits.append('%s=%s' % (attr, item))

        return '<%s>' % (' '.join(bits),)

    def parse(self, line):
        self.line = line

    def parse_counters(self, counters):
        self.packets, self.bytes = map(long, counters.strip('[]').split(':'))


class IPTablesTable(IPTablesFragment):
    def __str__(self):
        return '*%s' % (self.name,)

    def parse(self, line):
        self.name = line


class IPTablesPolicy(IPTablesFragment):
    def __str__(self):
        return ':%s' % (self.line,)

    def parse(self, line):
        super(IPTablesPolicy, self).parse(line)
        part = line.split()
        self.chain = part.pop(0)
        self.target = part.pop(0)
        self.parse_counters(part.pop(0))


class IPTablesRule(IPTablesFragment):
    def __str__(self):
        return self.line

    def parse(self, line):
        super(IPTablesRule, self).parse(line)
        part = line.split(' ', 1)
        self.parse_counters(part.pop(0))
        self.rule = part.pop(0)

        for option in self.rule[1:].split(' -'):
            if ' ' in option:
                option, value = option.split(' ', 1)
                if option not in IPTABLES_OPTIONS:
                    continue
                else:
                    setattr(self, IPTABLES_OPTIONS[option], value)


class RuleGroup(object):
    def __init__(self, chain, target):
        self.rules = []
        self.chain = chain
        self.target = target

    def __nonzero__(self):
        '''
        This is used in conditionals:

            >>> group = SortGroup()
            >>> if group:
            ...

        '''
        return bool(self.rules)

    def __cmp__(self, other):
        print self.chain, '__cmp__', other.chain
        return cmp(self.chain, other.chain)

    def __str__(self):
        output = ['# Rule group with target %s' % (self.target,)]
        output.extend(map(str, self.rules))
        return '\n'.join(output)

    def add(self, rule):
        self.rules.append(rule)

    def can_add(self, rule):
        return rule.target == self.target

    def sort_bytes(self):
        self.rules.sort(lambda a, b: cmp(b.bytes, a.bytes))

    def sort_packets(self):
        self.rules.sort(lambda a, b: cmp(b.packets, a.packets))


class IPTablesSort(object):
    format = '%a %b %d %H:%M:%S %Y'
    header = '# Generated by iptables-sort v0.1 on %s' % (format,)
    footer = '# Completed on %s' % (format,)

    def __init__(self, options):
        rules = self.load()
        group = {}
        output = []

        print datetime.datetime.now().strftime(self.header)
        for item in self.parse(rules):
            if isinstance(item, IPTablesTable):
                output.append(item)

            elif isinstance(item, IPTablesPolicy):
                output.append(item)

            elif isinstance(item, IPTablesRule):
                if self._match(item.chain, options.ignore_chain):
                    output.append(item)
                    continue

                block = (item.chain, item.target)
                if block not in group:
                    group[block] = RuleGroup(item.chain, item.target)
                    output.append(group[block])

                # Finally add rule
                group[block].add(item)

        # Sort target groups by reverse packet count
        for item in group.values():
            item.sort_packets()

        print '\n'.join(map(str, output))
        print 'COMMIT'
        print datetime.datetime.now().strftime(self.footer)

    def load(self):
        pipe = subprocess.Popen(
            [
                IPTABLES_SAVE,
                '--counters',
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        return pipe.stdout.read()

    def parse(self, lines):
        for line in lines.splitlines():
            line = line.strip()
            if line[0] == '#':
                continue
            elif line[0] == '*':
                yield IPTablesTable(line[1:])
            elif line[0] == ':':
                yield IPTablesPolicy(line[1:])
            elif line[0] == '[':
                yield IPTablesRule(line)

    def _match(self, name, patterns):
        for pattern in patterns:
            if fnmatch.fnmatchcase(name, pattern):
                return True
        return False


def run():
    import optparse

    parser = optparse.OptionParser()
    parser.add_option(
        '-c', '--ignore-chain', action='append', metavar='NAME',
        help='Skip re-ordering rules in chain')
    parser.add_option(
        '-B', '--sort-bytes', action='store_true', default=False,
        help='Sort by bytes rather than packet counts (default: no)')

    options, args = parser.parse_args()
    if options.ignore_chain:
        skip = []
        for chain in options.ignore_chain:
            skip.extend(chain.split(','))
        options.ignore_chain = skip
    else:
        options.ignore_chain = []

    IPTablesSort(options)

if __name__ == '__main__':
    sys.exit(run())
